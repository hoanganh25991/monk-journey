/**
 * Diablo Immortal PWA Service Worker
 * Auto-generated by update-service-worker.js
 * Enhanced with detailed progress reporting
 */

const CACHE_NAME = 'monk-journey-cache';
const CACHE_VERSION = '13'; // Incremented version to force update
const CACHE_KEY = CACHE_NAME + '-v' + CACHE_VERSION;

// Communication channel
let messagePort = null;

// Assets to cache - organized by type for better progress reporting
const ASSETS_TO_CACHE = [
  '',
  'index.html',
  'manifest.json',
  'css/animations.css',
  'css/components.css',
  'css/layout.css',
  'css/main.css',
  'css/mobile.css',
  'css/reset.css',
  'css/utilities.css',
  'js/config/index.js',
  'js/config/player-models.js',
  'js/config/skills.js',
  'js/core/AudioManager.js',
  'js/core/CollisionManager.js',
  'js/core/DifficultyManager.js',
  'js/core/Game.js',
  'js/core/HUDManager.js',
  'js/core/InputHandler.js',
  'js/core/PerformanceManager.js',
  'js/core/QuestManager.js',
  'js/core/SaveManager.js',
  'js/entities/Enemy.js',
  'js/entities/EnemyManager.js',
  'js/entities/player/FallbackPlayerModel.js',
  'js/entities/player/Player.js',
  'js/entities/player/PlayerCombat.js',
  'js/entities/player/PlayerInterface.js',
  'js/entities/player/PlayerInventory.js',
  'js/entities/player/PlayerModel.js',
  'js/entities/player/PlayerMovement.js',
  'js/entities/player/PlayerSkills.js',
  'js/entities/player/PlayerState.js',
  'js/entities/player/PlayerStats.js',
  'js/entities/skills/CycloneStrikeEffect.js',
  'js/entities/skills/ExplodingPalmEffect.js',
  'js/entities/skills/FistOfThunderEffect.js',
  'js/entities/skills/InnerSanctuaryEffect.js',
  'js/entities/skills/MysticAllyEffect.js',
  'js/entities/skills/SevenSidedStrikeEffect.js',
  'js/entities/skills/Skill.js',
  'js/entities/skills/SkillEffect.js',
  'js/entities/skills/SkillEffectFactory.js',
  'js/entities/skills/TeleportSkillEffect.js',
  'js/entities/skills/WaveOfLightEffect.js',
  'js/entities/skills/WaveStrikeEffect.js',
  'js/main.js',
  'js/ui/ModelPreview.js',
  'js/utils/AnimationUtils.js',
  'js/world/WorldManager.js',
  'js/world/environment/Bush.js',
  'js/world/environment/EnvironmentManager.js',
  'js/world/environment/Flower.js',
  'js/world/environment/Rock.js',
  'js/world/environment/Tree.js',
  'js/world/interactive/BossSpawnPoint.js',
  'js/world/interactive/InteractiveObjectManager.js',
  'js/world/interactive/QuestMarker.js',
  'js/world/interactive/TreasureChest.js',
  'js/world/lighting/LightingManager.js',
  'js/world/structures/Building.js',
  'js/world/structures/DarkSanctum.js',
  'js/world/structures/Ruins.js',
  'js/world/structures/StructureManager.js',
  'js/world/structures/Tower.js',
  'js/world/terrain/TerrainChunk.js',
  'js/world/terrain/TerrainManager.js',
  'js/world/utils/RandomGenerator.js',
  'js/world/utils/TextureGenerator.js',
  'js/world/zones/ZoneManager.js',
  'images/logo-192.png',
  'images/logo-192.svg',
  'images/logo-512.png',
  'images/logo-512.svg',
  'assets/audio/ally_dismiss.mp3',
  'assets/audio/ally_summon.mp3',
  'assets/audio/attack.mp3',
  'assets/audio/barrier_dissipate.mp3',
  'assets/audio/barrier_form.mp3',
  'assets/audio/battle_theme.mp3',
  'assets/audio/bell_fade.mp3',
  'assets/audio/bell_ring.mp3',
  'assets/audio/boss_death.mp3',
  'assets/audio/boss_theme.mp3',
  'assets/audio/button_click.mp3',
  'assets/audio/chest_open.mp3',
  'assets/audio/cyclone_strike.mp3',
  'assets/audio/door_open.mp3',
  'assets/audio/enemy_attack.mp3',
  'assets/audio/enemy_death.mp3',
  'assets/audio/enemy_hit.mp3',
  'assets/audio/exploding_palm.mp3',
  'assets/audio/fist_of_thunder.mp3',
  'assets/audio/inner_sanctuary.mp3',
  'assets/audio/inventory_open.mp3',
  'assets/audio/item_pickup.mp3',
  'assets/audio/level_up.mp3',
  'assets/audio/main_theme.mp3',
  'assets/audio/mark_applied.mp3',
  'assets/audio/massive_explosion.mp3',
  'assets/audio/mystic_ally.mp3',
  'assets/audio/player_death.mp3',
  'assets/audio/player_hit.mp3',
  'assets/audio/rapid_strike.mp3',
  'assets/audio/seven_sided_strike.mp3',
  'assets/audio/strike_complete.mp3',
  'assets/audio/thunder_echo.mp3',
  'assets/audio/thunder_strike.mp3',
  'assets/audio/water_dissipate.mp3',
  'assets/audio/water_impact.mp3',
  'assets/audio/wave_of_light.mp3',
  'assets/audio/wave_strike.mp3',
  'assets/audio/wind_dissipate.mp3',
  'assets/audio/wind_pull.mp3',
  'assets/images/background.jpg',
  'pwa/orientation-lock.js',
  'pwa/registration.js'
];

// Function to send progress updates to the client
function sendProgressUpdate(completed, total, currentFile) {
  if (messagePort) {
    messagePort.postMessage({
      type: 'CACHE_PROGRESS',
      completed,
      total,
      currentFile
    });
  }
}

// Function to cache files with progress tracking
async function cacheFilesWithProgress(cache) {
  const total = ASSETS_TO_CACHE.length;
  let completed = 0;
  
  // Process files sequentially to ensure accurate progress tracking
  for (const url of ASSETS_TO_CACHE) {
    try {
      // Send progress update before starting the fetch
      sendProgressUpdate(completed, total, url);
      
      // Fetch and cache the file
      const response = await fetch(url);
      if (response.ok) {
        await cache.put(url, response);
        completed++;
        
        // Send progress update after successful caching
        sendProgressUpdate(completed, total, url);
      } else {
        console.warn(`Failed to cache ${url}: ${response.status} ${response.statusText}`);
        // Still increment completed to keep progress moving
        completed++;
        sendProgressUpdate(completed, total, `Failed: ${url}`);
      }
    } catch (error) {
      console.error(`Error caching ${url}:`, error);
      // Still increment completed to keep progress moving
      completed++;
      sendProgressUpdate(completed, total, `Error: ${url}`);
    }
  }
  
  return completed;
}

// Listen for messages from the client
self.addEventListener('message', event => {
  // Check if it's the initialization message with the port
  if (event.data && event.data.type === 'INIT_PORT') {
    messagePort = event.data.port;
    console.log('Communication channel established with client');
  }
});

// Install event - cache all static assets with progress tracking
self.addEventListener('install', event => {
  event.waitUntil(
    caches.open(CACHE_KEY)
      .then(cache => {
        console.log('Caching app assets with progress tracking');
        return cacheFilesWithProgress(cache);
      })
      .then(completedCount => {
        console.log(`Cached ${completedCount} files successfully`);
        return self.skipWaiting();
      })
      .catch(error => {
        console.error('Failed to cache assets:', error);
      })
  );
});

// Activate event - clean up old caches
self.addEventListener('activate', event => {
  event.waitUntil(
    caches.keys().then(cacheNames => {
      return Promise.all(
        cacheNames.filter(cacheName => {
          return cacheName.startsWith(CACHE_NAME) && cacheName !== CACHE_KEY;
        }).map(cacheName => {
          console.log('Deleting old cache:', cacheName);
          return caches.delete(cacheName);
        })
      );
    }).then(() => {
      return self.clients.claim();
    })
  );
});

// Fetch event - serve from cache, fall back to network
self.addEventListener('fetch', event => {
  event.respondWith(
    caches.match(event.request)
      .then(response => {
        if (response) {
          return response;
        }
        return fetch(event.request);
      })
      .catch(error => {
        console.error('Fetch error:', error);
        // You could return a custom offline page here
      })
  );
});
